<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Î¨∏ÎèÑ ÌîºÍµ¨ PVP ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; }
    canvas { display: block; background: #222; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
const socket = io("https://moondo-production.up.railway.app"); // Ïó¨Í∏∞Î•º Ïã§Ï†ú Î∞∞Ìè¨ Ï£ºÏÜåÎ°ú ÍµêÏ≤¥ÌïòÏÑ∏Ïöî

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const player = {
  x: canvas.width / 2,
  y: canvas.height * 0.85,
  radius: 20,
  color: 'cyan',
  speed: 3,
  targetX: canvas.width / 2,
  targetY: canvas.height * 0.85,
  facingAngle: -Math.PI / 2,
  hp: 100
};

const enemy = {
  x: canvas.width / 2,
  y: canvas.height * 0.15,
  radius: 20,
  color: 'orange',
  hp: 100
};

const axes = [];
const opponentAxes = [];
const AXE_SPEED = 5;
const AXE_MAX_DISTANCE = 400;
const COOLDOWN = 2000;
let lastThrowTime = 0;

let gameOver = false;
let gameResult = "";

const arena = {
  width: canvas.width,
  height: canvas.height,
  boundaryY: canvas.height / 2,
};

canvas.addEventListener('contextmenu', e => e.preventDefault());

let mouseX = player.x;
let mouseY = player.y;

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
  player.facingAngle = Math.atan2(mouseY - player.y, mouseX - player.x);
});

canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (e.button === 2) {
    player.targetX = x;
    player.targetY = y;
  }
});

window.addEventListener('keydown', (e) => {
  if (gameOver) return;
  if (e.key.toLowerCase() === 'q') {
    const now = Date.now();
    if (now - lastThrowTime >= COOLDOWN) {
      const angle = player.facingAngle;
      const axe = {
        x: player.x,
        y: player.y,
        vx: Math.cos(angle) * AXE_SPEED,
        vy: Math.sin(angle) * AXE_SPEED,
        angle: 0,
        radius: 10,
        color: 'red',
        distanceTraveled: 0,
        maxDistance: AXE_MAX_DISTANCE,
        alive: true,
        fade: 1.0,
        hit: false
      };
      axes.push(axe);
      socket.emit("spawn_axe", axe);
      lastThrowTime = now;
    }
  }
});

socket.on("game_start", () => {
  console.log("üéÆ Í≤åÏûÑ ÏãúÏûë!");
});

socket.on("opponent_action", (data) => {
  enemy.x = data.x;
  enemy.y = data.y;
  enemy.facingAngle = data.facingAngle;
});

socket.on("opponent_axe", (axe) => {
  axe.angle = 0;
  axe.fade = 1.0;
  axe.hit = false;
  axe.alive = true;
  opponentAxes.push(axe);
});

socket.on("take_damage", (damage) => {
  player.hp = Math.max(0, player.hp - damage);
});

socket.on("opponent_disconnected", () => {
  gameOver = true;
  gameResult = "ÏÉÅÎåÄÎ∞© Ïó∞Í≤∞ Ï¢ÖÎ£å";
});

function update() {
  if (gameOver) return;

  const dx = player.targetX - player.x;
  const dy = player.targetY - player.y;
  const dist = Math.hypot(dx, dy);
  if (dist > 1) {
    const nextX = player.x + (dx / dist) * player.speed;
    const nextY = player.y + (dy / dist) * player.speed;
    if (nextY >= arena.boundaryY) {
      player.x = nextX;
      player.y = nextY;
    }
  }

  socket.emit("player_action", {
    x: player.x,
    y: player.y,
    facingAngle: player.facingAngle
  });

  axes.forEach(axe => updateAxe(axe, enemy));
  opponentAxes.forEach(axe => updateAxe(axe, player, true));

  if (player.hp <= 0) {
    gameOver = true;
    gameResult = "Defeat";
  } else if (enemy.hp <= 0) {
    gameOver = true;
    gameResult = "Victory";
  }
}

function updateAxe(axe, target, isEnemy = false) {
  if (!axe.alive) {
    axe.fade -= 0.02;
    return;
  }
  axe.x += axe.vx;
  axe.y += axe.vy;
  axe.angle += 0.3;
  axe.distanceTraveled += Math.hypot(axe.vx, axe.vy);

  if (!axe.hit && isColliding(axe, target)) {
    axe.hit = true;
    axe.alive = false;
    if (!isEnemy) socket.emit("hit", 20);
    else target.hp = Math.max(0, target.hp - 20);
  }
  if (axe.distanceTraveled >= axe.maxDistance) axe.alive = false;
}

function isColliding(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  return distance < a.radius + b.radius;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = 'white';
  ctx.beginPath();
  ctx.moveTo(0, arena.boundaryY);
  ctx.lineTo(canvas.width, arena.boundaryY);
  ctx.stroke();

  drawRotatedTriangle(player.x, player.y, player.radius, player.facingAngle, player.color);
  drawRotatedTriangle(enemy.x, enemy.y, enemy.radius, enemy.facingAngle || 0, enemy.color);
  drawHealthBar(player);
  drawHealthBar(enemy);
  drawCooldownIndicator();

  axes.forEach(axe => drawRotatedAxe(axe));
  opponentAxes.forEach(axe => drawRotatedAxe(axe));

  if (gameOver) {
    ctx.fillStyle = 'white';
    ctx.font = '48px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(gameResult, canvas.width / 2, canvas.height / 2);
  }
}

function drawCooldownIndicator() {
  const x = 20;
  const y = canvas.height - 80;
  const radius = 30;
  const now = Date.now();
  const elapsed = now - lastThrowTime;
  const cooldownRatio = Math.min(elapsed / COOLDOWN, 1);

  ctx.save();
  ctx.translate(x + radius, y + radius);
  ctx.beginPath();
  ctx.fillStyle = '#444';
  ctx.arc(0, 0, radius, 0, Math.PI * 2);
  ctx.fill();

  if (cooldownRatio < 1) {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.arc(0, 0, radius, -Math.PI / 2, -Math.PI / 2 + cooldownRatio * 2 * Math.PI);
    ctx.lineTo(0, 0);
    ctx.fill();
  }

  ctx.fillStyle = 'black';
  ctx.font = '16px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Q', 0, 0);
  ctx.restore();
}

function drawHealthBar(character) {
  const barWidth = 100;
  const barHeight = 8;
  const x = character.x - barWidth / 2;
  const y = character.y - character.radius - 15;
  ctx.fillStyle = 'gray';
  ctx.fillRect(x, y, barWidth, barHeight);
  ctx.fillStyle = 'lime';
  ctx.fillRect(x, y, (character.hp / 100) * barWidth, barHeight);
}

function drawRotatedTriangle(x, y, radius, angle, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
  ctx.lineTo(x + Math.cos(angle + Math.PI * 0.75) * radius, y + Math.sin(angle + Math.PI * 0.75) * radius);
  ctx.lineTo(x + Math.cos(angle - Math.PI * 0.75) * radius, y + Math.sin(angle - Math.PI * 0.75) * radius);
  ctx.closePath();
  ctx.fill();
}

function drawRotatedAxe(axe) {
  ctx.save();
  ctx.translate(axe.x, axe.y);
  ctx.rotate(axe.angle);
  ctx.globalAlpha = axe.fade;
  ctx.fillStyle = axe.color;
  ctx.fillRect(-axe.radius, -axe.radius / 2, axe.radius * 2, axe.radius);
  ctx.globalAlpha = 1.0;
  ctx.restore();
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
