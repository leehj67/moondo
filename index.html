<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Î¨∏ÎèÑ ÌîºÍµ¨ PVP</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; }
    canvas { display: block; background: #222; }
    #qButton {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      background: #fff;
      border-radius: 50%;
      font-size: 24px;
      font-weight: bold;
      color: black;
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0.8;
      user-select: none;
      z-index: 10;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="qButton">Q</div>

<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
const socket = io("https://moondo-production.up.railway.app");

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const player = {
  x: canvas.width / 2,
  y: canvas.height * 0.85,
  radius: 20,
  color: 'cyan',
  speed: 3,
  targetX: canvas.width / 2,
  targetY: canvas.height * 0.85,
  facingAngle: -Math.PI / 2,
  hp: 100
};

const enemy = {
  x: canvas.width / 2,
  y: canvas.height * 0.15,
  radius: 20,
  color: 'orange',
  hp: 100
};

const axes = [];
const opponentAxes = [];
const AXE_SPEED = 5;
const AXE_MAX_DISTANCE = 400;
const COOLDOWN = 2000;
let lastThrowTime = 0;

let gameOver = false;
let gameResult = "";

const arena = {
  width: canvas.width,
  height: canvas.height,
  boundaryY: canvas.height / 2,
};

canvas.addEventListener('contextmenu', e => e.preventDefault());
let mouseX = player.x, mouseY = player.y;

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
  player.facingAngle = Math.atan2(mouseY - player.y, mouseX - player.y);
});

canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (e.button === 2) {
    player.targetX = x;
    player.targetY = y;
  }
});

// Î™®Î∞îÏùº ÌÑ∞ÏπòÎ°ú Ïù¥Îèô
canvas.addEventListener("touchstart", (e) => {
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  const x = touch.clientX - rect.left;
  const y = touch.clientY - rect.top;
  player.targetX = x;
  player.targetY = y;
  player.facingAngle = Math.atan2(y - player.y, x - player.x);
});

// Î™®Î∞îÏùº Q Î≤ÑÌäº
document.getElementById('qButton').addEventListener('touchstart', () => {
  throwAxe();
});

// PCÏö© Q ÌÇ§
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'q') throwAxe();
});

function throwAxe() {
  const now = Date.now();
  if (now - lastThrowTime >= COOLDOWN) {
    const angle = player.facingAngle;
    const axe = {
      x: player.x,
      y: player.y,
      vx: Math.cos(angle) * AXE_SPEED,
      vy: Math.sin(angle) * AXE_SPEED,
      angle: 0,
      radius: 10,
      color: 'red',
      distanceTraveled: 0,
      maxDistance: AXE_MAX_DISTANCE,
      alive: true,
      fade: 1.0,
      hit: false
    };
    axes.push(axe);
    socket.emit("spawn_axe", axe);
    lastThrowTime = Date.now();
  }
}

socket.on("game_start", () => {
  console.log("üéÆ Í≤åÏûÑ ÏãúÏûë");
});

socket.on("opponent_action", (data) => {
  enemy.x = data.x;
  enemy.y = data.y;
  enemy.facingAngle = data.facingAngle;
});

socket.on("opponent_axe", (axe) => {
  axe.angle = 0;
  axe.fade = 1.0;
  axe.hit = false;
  axe.alive = true;
  opponentAxes.push(axe);
});

socket.on("take_damage", (damage) => {
  player.hp = Math.max(0, player.hp - damage);
});

socket.on("opponent_disconnected", () => {
  gameOver = true;
  gameResult = "ÏÉÅÎåÄÎ∞© Ïó∞Í≤∞ Ï¢ÖÎ£å";
});

function update() {
  if (gameOver) return;
  const dx = player.targetX - player.x;
  const dy = player.targetY - player.y;
  const dist = Math.hypot(dx, dy);
  if (dist > 1) {
    const nextX = player.x + (dx / dist) * player.speed;
    const nextY = player.y + (dy / dist) * player.speed;
    if (nextY >= arena.boundaryY) {
      player.x = nextX;
      player.y = nextY;
    }
  }

  socket.emit("player_action", {
    x: player.x,
    y: player.y,
    facingAngle: player.facingAngle
  });

  axes.forEach(axe => updateAxe(axe, enemy));
  opponentAxes.forEach(axe => updateAxe(axe, player, true));

  if (player.hp <= 0) {
    gameOver = true;
    gameResult = "Defeat";
  } else if (enemy.hp <= 0) {
    gameOver = true;
    gameResult = "Victory";
  }
}

function updateAxe(axe, target, isEnemy = false) {
  if (!axe.alive) {
    axe.fade -= 0.02;
    return;
  }
  axe.x += axe.vx;
  axe.y += axe.vy;
  axe.angle += 0.3;
  axe.distanceTraveled += Math.hypot(axe.vx, axe.vy);

  if (!axe.hit && isColliding(axe, target)) {
    axe.hit = true;
    axe.alive = false;
    if (!isEnemy) socket.emit("hit", 20);
    else target.hp = Math.max(0, target.hp - 20);
  }

  if (axe.distanceTraveled >= axe.maxDistance) axe.alive = false;
}

function isColliding(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.hypot(dx, dy) < a.radius + b.radius;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = 'white';
  ctx.beginPath();
  ctx.moveTo(0, arena.boundaryY);
  ctx.lineTo(canvas.width, arena.boundaryY);
  ctx.stroke();

  drawRotatedTriangle(player.x, player.y, player.radius, player.facingAngle, player.color);
  drawRotatedTriangle(enemy.x, enemy.y, enemy.radius, enemy.facingAngle || 0, enemy.color);
  drawHealthBar(player);
  drawHealthBar(enemy);
  drawCooldownIndicator();

  axes.forEach(axe => drawRotatedAxe(axe));
  opponentAxes.forEach(axe => drawRotatedAxe(axe));

  if (gameOver) {
    ctx.fillStyle = 'white';
    ctx.font = '48px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(gameResult, canvas.width / 2, canvas.height / 2);
  }
}

function drawCooldownIndicator() {
  const x = 20, y = canvas.height - 80, radius = 30;
  const now = Date.now();
  const elapsed = now - lastThrowTime;
  const cooldownRatio = Math.min(elapsed / COOLDOWN, 1);

  ctx.save();
  ctx.translate(x + radius, y + radius);
  ctx.beginPath();
  ctx.fillStyle = '#444';
  ctx.arc(0, 0, radius, 0, Math.PI * 2);
  ctx.fill();

  if (cooldownRatio < 1) {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.arc(0, 0, radius, -Math.PI / 2, -Math.PI / 2 + cooldownRatio * 2 * Math.PI);
    ctx.lineTo(0, 0);
    ctx.fill();
  }

  ctx.fillStyle = 'black';
  ctx.font = '16px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Q', 0, 0);
  ctx.restore();
}

function drawHealthBar(c) {
  const w = 100, h = 8;
  ctx.fillStyle = 'gray';
  ctx.fillRect(c.x - w / 2, c.y - c.radius - 15, w, h);
  ctx.fillStyle = 'lime';
  ctx.fillRect(c.x - w / 2, c.y - c.radius - 15, (c.hp / 100) * w, h);
}

function drawRotatedTriangle(x, y, r, angle, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x + Math.cos(angle) * r, y + Math.sin(angle) * r);
  ctx.lineTo(x + Math.cos(angle + Math.PI * 0.75) * r, y + Math.sin(angle + Math.PI * 0.75) * r);
  ctx.lineTo(x + Math.cos(angle - Math.PI * 0.75) * r, y + Math.sin(angle - Math.PI * 0.75) * r);
  ctx.closePath();
  ctx.fill();
}

function drawRotatedAxe(axe) {
  ctx.save();
  ctx.translate(axe.x, axe.y);
  ctx.rotate(axe.angle);
  ctx.globalAlpha = axe.fade;
  ctx.fillStyle = axe.color;
  ctx.fillRect(-axe.radius, -axe.radius / 2, axe.radius * 2, axe.radius);
  ctx.globalAlpha = 1.0;
  ctx.restore();
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
